// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// UserDevice is an object representing the database table.
type UserDevice struct {
	ID                 string            `boil:"id" json:"id" toml:"id" yaml:"id"`
	UserID             string            `boil:"user_id" json:"user_id" toml:"user_id" yaml:"user_id"`
	DeviceDefinitionID string            `boil:"device_definition_id" json:"device_definition_id" toml:"device_definition_id" yaml:"device_definition_id"`
	VinIdentifier      null.String       `boil:"vin_identifier" json:"vin_identifier,omitempty" toml:"vin_identifier" yaml:"vin_identifier,omitempty"`
	Name               null.String       `boil:"name" json:"name,omitempty" toml:"name" yaml:"name,omitempty"`
	CustomImageURL     null.String       `boil:"custom_image_url" json:"custom_image_url,omitempty" toml:"custom_image_url" yaml:"custom_image_url,omitempty"`
	CountryCode        null.String       `boil:"country_code" json:"country_code,omitempty" toml:"country_code" yaml:"country_code,omitempty"`
	CreatedAt          time.Time         `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt          time.Time         `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	VinConfirmed       bool              `boil:"vin_confirmed" json:"vin_confirmed" toml:"vin_confirmed" yaml:"vin_confirmed"`
	Metadata           null.JSON         `boil:"metadata" json:"metadata,omitempty" toml:"metadata" yaml:"metadata,omitempty"`
	DeviceStyleID      null.String       `boil:"device_style_id" json:"device_style_id,omitempty" toml:"device_style_id" yaml:"device_style_id,omitempty"`
	OptedInAt          null.Time         `boil:"opted_in_at" json:"opted_in_at,omitempty" toml:"opted_in_at" yaml:"opted_in_at,omitempty"`
	MintRequestID      null.String       `boil:"mint_request_id" json:"mint_request_id,omitempty" toml:"mint_request_id" yaml:"mint_request_id,omitempty"`
	BurnRequestID      null.String       `boil:"burn_request_id" json:"burn_request_id,omitempty" toml:"burn_request_id" yaml:"burn_request_id,omitempty"`
	TokenID            types.NullDecimal `boil:"token_id" json:"token_id,omitempty" toml:"token_id" yaml:"token_id,omitempty"`
	OwnerAddress       null.Bytes        `boil:"owner_address" json:"owner_address,omitempty" toml:"owner_address" yaml:"owner_address,omitempty"`
	IpfsImageCid       null.String       `boil:"ipfs_image_cid" json:"ipfs_image_cid,omitempty" toml:"ipfs_image_cid" yaml:"ipfs_image_cid,omitempty"`
	DefinitionID       string            `boil:"definition_id" json:"definition_id" toml:"definition_id" yaml:"definition_id"`

	R *userDeviceR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L userDeviceL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var UserDeviceColumns = struct {
	ID                 string
	UserID             string
	DeviceDefinitionID string
	VinIdentifier      string
	Name               string
	CustomImageURL     string
	CountryCode        string
	CreatedAt          string
	UpdatedAt          string
	VinConfirmed       string
	Metadata           string
	DeviceStyleID      string
	OptedInAt          string
	MintRequestID      string
	BurnRequestID      string
	TokenID            string
	OwnerAddress       string
	IpfsImageCid       string
	DefinitionID       string
}{
	ID:                 "id",
	UserID:             "user_id",
	DeviceDefinitionID: "device_definition_id",
	VinIdentifier:      "vin_identifier",
	Name:               "name",
	CustomImageURL:     "custom_image_url",
	CountryCode:        "country_code",
	CreatedAt:          "created_at",
	UpdatedAt:          "updated_at",
	VinConfirmed:       "vin_confirmed",
	Metadata:           "metadata",
	DeviceStyleID:      "device_style_id",
	OptedInAt:          "opted_in_at",
	MintRequestID:      "mint_request_id",
	BurnRequestID:      "burn_request_id",
	TokenID:            "token_id",
	OwnerAddress:       "owner_address",
	IpfsImageCid:       "ipfs_image_cid",
	DefinitionID:       "definition_id",
}

var UserDeviceTableColumns = struct {
	ID                 string
	UserID             string
	DeviceDefinitionID string
	VinIdentifier      string
	Name               string
	CustomImageURL     string
	CountryCode        string
	CreatedAt          string
	UpdatedAt          string
	VinConfirmed       string
	Metadata           string
	DeviceStyleID      string
	OptedInAt          string
	MintRequestID      string
	BurnRequestID      string
	TokenID            string
	OwnerAddress       string
	IpfsImageCid       string
	DefinitionID       string
}{
	ID:                 "user_devices.id",
	UserID:             "user_devices.user_id",
	DeviceDefinitionID: "user_devices.device_definition_id",
	VinIdentifier:      "user_devices.vin_identifier",
	Name:               "user_devices.name",
	CustomImageURL:     "user_devices.custom_image_url",
	CountryCode:        "user_devices.country_code",
	CreatedAt:          "user_devices.created_at",
	UpdatedAt:          "user_devices.updated_at",
	VinConfirmed:       "user_devices.vin_confirmed",
	Metadata:           "user_devices.metadata",
	DeviceStyleID:      "user_devices.device_style_id",
	OptedInAt:          "user_devices.opted_in_at",
	MintRequestID:      "user_devices.mint_request_id",
	BurnRequestID:      "user_devices.burn_request_id",
	TokenID:            "user_devices.token_id",
	OwnerAddress:       "user_devices.owner_address",
	IpfsImageCid:       "user_devices.ipfs_image_cid",
	DefinitionID:       "user_devices.definition_id",
}

// Generated where

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

var UserDeviceWhere = struct {
	ID                 whereHelperstring
	UserID             whereHelperstring
	DeviceDefinitionID whereHelperstring
	VinIdentifier      whereHelpernull_String
	Name               whereHelpernull_String
	CustomImageURL     whereHelpernull_String
	CountryCode        whereHelpernull_String
	CreatedAt          whereHelpertime_Time
	UpdatedAt          whereHelpertime_Time
	VinConfirmed       whereHelperbool
	Metadata           whereHelpernull_JSON
	DeviceStyleID      whereHelpernull_String
	OptedInAt          whereHelpernull_Time
	MintRequestID      whereHelpernull_String
	BurnRequestID      whereHelpernull_String
	TokenID            whereHelpertypes_NullDecimal
	OwnerAddress       whereHelpernull_Bytes
	IpfsImageCid       whereHelpernull_String
	DefinitionID       whereHelperstring
}{
	ID:                 whereHelperstring{field: "\"devices_api\".\"user_devices\".\"id\""},
	UserID:             whereHelperstring{field: "\"devices_api\".\"user_devices\".\"user_id\""},
	DeviceDefinitionID: whereHelperstring{field: "\"devices_api\".\"user_devices\".\"device_definition_id\""},
	VinIdentifier:      whereHelpernull_String{field: "\"devices_api\".\"user_devices\".\"vin_identifier\""},
	Name:               whereHelpernull_String{field: "\"devices_api\".\"user_devices\".\"name\""},
	CustomImageURL:     whereHelpernull_String{field: "\"devices_api\".\"user_devices\".\"custom_image_url\""},
	CountryCode:        whereHelpernull_String{field: "\"devices_api\".\"user_devices\".\"country_code\""},
	CreatedAt:          whereHelpertime_Time{field: "\"devices_api\".\"user_devices\".\"created_at\""},
	UpdatedAt:          whereHelpertime_Time{field: "\"devices_api\".\"user_devices\".\"updated_at\""},
	VinConfirmed:       whereHelperbool{field: "\"devices_api\".\"user_devices\".\"vin_confirmed\""},
	Metadata:           whereHelpernull_JSON{field: "\"devices_api\".\"user_devices\".\"metadata\""},
	DeviceStyleID:      whereHelpernull_String{field: "\"devices_api\".\"user_devices\".\"device_style_id\""},
	OptedInAt:          whereHelpernull_Time{field: "\"devices_api\".\"user_devices\".\"opted_in_at\""},
	MintRequestID:      whereHelpernull_String{field: "\"devices_api\".\"user_devices\".\"mint_request_id\""},
	BurnRequestID:      whereHelpernull_String{field: "\"devices_api\".\"user_devices\".\"burn_request_id\""},
	TokenID:            whereHelpertypes_NullDecimal{field: "\"devices_api\".\"user_devices\".\"token_id\""},
	OwnerAddress:       whereHelpernull_Bytes{field: "\"devices_api\".\"user_devices\".\"owner_address\""},
	IpfsImageCid:       whereHelpernull_String{field: "\"devices_api\".\"user_devices\".\"ipfs_image_cid\""},
	DefinitionID:       whereHelperstring{field: "\"devices_api\".\"user_devices\".\"definition_id\""},
}

// UserDeviceRels is where relationship names are stored.
var UserDeviceRels = struct {
	BurnRequest                   string
	MintRequest                   string
	VehicleTokenAftermarketDevice string
	VehicleTokenSyntheticDevice   string
	AutopiJobs                    string
	DeviceCommandRequests         string
	ErrorCodeQueries              string
	VehicleTokenErrorCodeQueries  string
	UserDeviceAPIIntegrations     string
	UserDeviceToGeofences         string
}{
	BurnRequest:                   "BurnRequest",
	MintRequest:                   "MintRequest",
	VehicleTokenAftermarketDevice: "VehicleTokenAftermarketDevice",
	VehicleTokenSyntheticDevice:   "VehicleTokenSyntheticDevice",
	AutopiJobs:                    "AutopiJobs",
	DeviceCommandRequests:         "DeviceCommandRequests",
	ErrorCodeQueries:              "ErrorCodeQueries",
	VehicleTokenErrorCodeQueries:  "VehicleTokenErrorCodeQueries",
	UserDeviceAPIIntegrations:     "UserDeviceAPIIntegrations",
	UserDeviceToGeofences:         "UserDeviceToGeofences",
}

// userDeviceR is where relationships are stored.
type userDeviceR struct {
	BurnRequest                   *MetaTransactionRequest       `boil:"BurnRequest" json:"BurnRequest" toml:"BurnRequest" yaml:"BurnRequest"`
	MintRequest                   *MetaTransactionRequest       `boil:"MintRequest" json:"MintRequest" toml:"MintRequest" yaml:"MintRequest"`
	VehicleTokenAftermarketDevice *AftermarketDevice            `boil:"VehicleTokenAftermarketDevice" json:"VehicleTokenAftermarketDevice" toml:"VehicleTokenAftermarketDevice" yaml:"VehicleTokenAftermarketDevice"`
	VehicleTokenSyntheticDevice   *SyntheticDevice              `boil:"VehicleTokenSyntheticDevice" json:"VehicleTokenSyntheticDevice" toml:"VehicleTokenSyntheticDevice" yaml:"VehicleTokenSyntheticDevice"`
	AutopiJobs                    AutopiJobSlice                `boil:"AutopiJobs" json:"AutopiJobs" toml:"AutopiJobs" yaml:"AutopiJobs"`
	DeviceCommandRequests         DeviceCommandRequestSlice     `boil:"DeviceCommandRequests" json:"DeviceCommandRequests" toml:"DeviceCommandRequests" yaml:"DeviceCommandRequests"`
	ErrorCodeQueries              ErrorCodeQuerySlice           `boil:"ErrorCodeQueries" json:"ErrorCodeQueries" toml:"ErrorCodeQueries" yaml:"ErrorCodeQueries"`
	VehicleTokenErrorCodeQueries  ErrorCodeQuerySlice           `boil:"VehicleTokenErrorCodeQueries" json:"VehicleTokenErrorCodeQueries" toml:"VehicleTokenErrorCodeQueries" yaml:"VehicleTokenErrorCodeQueries"`
	UserDeviceAPIIntegrations     UserDeviceAPIIntegrationSlice `boil:"UserDeviceAPIIntegrations" json:"UserDeviceAPIIntegrations" toml:"UserDeviceAPIIntegrations" yaml:"UserDeviceAPIIntegrations"`
	UserDeviceToGeofences         UserDeviceToGeofenceSlice     `boil:"UserDeviceToGeofences" json:"UserDeviceToGeofences" toml:"UserDeviceToGeofences" yaml:"UserDeviceToGeofences"`
}

// NewStruct creates a new relationship struct
func (*userDeviceR) NewStruct() *userDeviceR {
	return &userDeviceR{}
}

func (r *userDeviceR) GetBurnRequest() *MetaTransactionRequest {
	if r == nil {
		return nil
	}
	return r.BurnRequest
}

func (r *userDeviceR) GetMintRequest() *MetaTransactionRequest {
	if r == nil {
		return nil
	}
	return r.MintRequest
}

func (r *userDeviceR) GetVehicleTokenAftermarketDevice() *AftermarketDevice {
	if r == nil {
		return nil
	}
	return r.VehicleTokenAftermarketDevice
}

func (r *userDeviceR) GetVehicleTokenSyntheticDevice() *SyntheticDevice {
	if r == nil {
		return nil
	}
	return r.VehicleTokenSyntheticDevice
}

func (r *userDeviceR) GetAutopiJobs() AutopiJobSlice {
	if r == nil {
		return nil
	}
	return r.AutopiJobs
}

func (r *userDeviceR) GetDeviceCommandRequests() DeviceCommandRequestSlice {
	if r == nil {
		return nil
	}
	return r.DeviceCommandRequests
}

func (r *userDeviceR) GetErrorCodeQueries() ErrorCodeQuerySlice {
	if r == nil {
		return nil
	}
	return r.ErrorCodeQueries
}

func (r *userDeviceR) GetVehicleTokenErrorCodeQueries() ErrorCodeQuerySlice {
	if r == nil {
		return nil
	}
	return r.VehicleTokenErrorCodeQueries
}

func (r *userDeviceR) GetUserDeviceAPIIntegrations() UserDeviceAPIIntegrationSlice {
	if r == nil {
		return nil
	}
	return r.UserDeviceAPIIntegrations
}

func (r *userDeviceR) GetUserDeviceToGeofences() UserDeviceToGeofenceSlice {
	if r == nil {
		return nil
	}
	return r.UserDeviceToGeofences
}

// userDeviceL is where Load methods for each relationship are stored.
type userDeviceL struct{}

var (
	userDeviceAllColumns            = []string{"id", "user_id", "device_definition_id", "vin_identifier", "name", "custom_image_url", "country_code", "created_at", "updated_at", "vin_confirmed", "metadata", "device_style_id", "opted_in_at", "mint_request_id", "burn_request_id", "token_id", "owner_address", "ipfs_image_cid", "definition_id"}
	userDeviceColumnsWithoutDefault = []string{"id", "user_id", "device_definition_id", "definition_id"}
	userDeviceColumnsWithDefault    = []string{"vin_identifier", "name", "custom_image_url", "country_code", "created_at", "updated_at", "vin_confirmed", "metadata", "device_style_id", "opted_in_at", "mint_request_id", "burn_request_id", "token_id", "owner_address", "ipfs_image_cid"}
	userDevicePrimaryKeyColumns     = []string{"id"}
	userDeviceGeneratedColumns      = []string{}
)

type (
	// UserDeviceSlice is an alias for a slice of pointers to UserDevice.
	// This should almost always be used instead of []UserDevice.
	UserDeviceSlice []*UserDevice
	// UserDeviceHook is the signature for custom UserDevice hook methods
	UserDeviceHook func(context.Context, boil.ContextExecutor, *UserDevice) error

	userDeviceQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	userDeviceType                 = reflect.TypeOf(&UserDevice{})
	userDeviceMapping              = queries.MakeStructMapping(userDeviceType)
	userDevicePrimaryKeyMapping, _ = queries.BindMapping(userDeviceType, userDeviceMapping, userDevicePrimaryKeyColumns)
	userDeviceInsertCacheMut       sync.RWMutex
	userDeviceInsertCache          = make(map[string]insertCache)
	userDeviceUpdateCacheMut       sync.RWMutex
	userDeviceUpdateCache          = make(map[string]updateCache)
	userDeviceUpsertCacheMut       sync.RWMutex
	userDeviceUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var userDeviceAfterSelectMu sync.Mutex
var userDeviceAfterSelectHooks []UserDeviceHook

var userDeviceBeforeInsertMu sync.Mutex
var userDeviceBeforeInsertHooks []UserDeviceHook
var userDeviceAfterInsertMu sync.Mutex
var userDeviceAfterInsertHooks []UserDeviceHook

var userDeviceBeforeUpdateMu sync.Mutex
var userDeviceBeforeUpdateHooks []UserDeviceHook
var userDeviceAfterUpdateMu sync.Mutex
var userDeviceAfterUpdateHooks []UserDeviceHook

var userDeviceBeforeDeleteMu sync.Mutex
var userDeviceBeforeDeleteHooks []UserDeviceHook
var userDeviceAfterDeleteMu sync.Mutex
var userDeviceAfterDeleteHooks []UserDeviceHook

var userDeviceBeforeUpsertMu sync.Mutex
var userDeviceBeforeUpsertHooks []UserDeviceHook
var userDeviceAfterUpsertMu sync.Mutex
var userDeviceAfterUpsertHooks []UserDeviceHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *UserDevice) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userDeviceAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *UserDevice) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userDeviceBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *UserDevice) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userDeviceAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *UserDevice) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userDeviceBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *UserDevice) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userDeviceAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *UserDevice) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userDeviceBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *UserDevice) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userDeviceAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *UserDevice) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userDeviceBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *UserDevice) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userDeviceAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddUserDeviceHook registers your hook function for all future operations.
func AddUserDeviceHook(hookPoint boil.HookPoint, userDeviceHook UserDeviceHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		userDeviceAfterSelectMu.Lock()
		userDeviceAfterSelectHooks = append(userDeviceAfterSelectHooks, userDeviceHook)
		userDeviceAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		userDeviceBeforeInsertMu.Lock()
		userDeviceBeforeInsertHooks = append(userDeviceBeforeInsertHooks, userDeviceHook)
		userDeviceBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		userDeviceAfterInsertMu.Lock()
		userDeviceAfterInsertHooks = append(userDeviceAfterInsertHooks, userDeviceHook)
		userDeviceAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		userDeviceBeforeUpdateMu.Lock()
		userDeviceBeforeUpdateHooks = append(userDeviceBeforeUpdateHooks, userDeviceHook)
		userDeviceBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		userDeviceAfterUpdateMu.Lock()
		userDeviceAfterUpdateHooks = append(userDeviceAfterUpdateHooks, userDeviceHook)
		userDeviceAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		userDeviceBeforeDeleteMu.Lock()
		userDeviceBeforeDeleteHooks = append(userDeviceBeforeDeleteHooks, userDeviceHook)
		userDeviceBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		userDeviceAfterDeleteMu.Lock()
		userDeviceAfterDeleteHooks = append(userDeviceAfterDeleteHooks, userDeviceHook)
		userDeviceAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		userDeviceBeforeUpsertMu.Lock()
		userDeviceBeforeUpsertHooks = append(userDeviceBeforeUpsertHooks, userDeviceHook)
		userDeviceBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		userDeviceAfterUpsertMu.Lock()
		userDeviceAfterUpsertHooks = append(userDeviceAfterUpsertHooks, userDeviceHook)
		userDeviceAfterUpsertMu.Unlock()
	}
}

// One returns a single userDevice record from the query.
func (q userDeviceQuery) One(ctx context.Context, exec boil.ContextExecutor) (*UserDevice, error) {
	o := &UserDevice{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for user_devices")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all UserDevice records from the query.
func (q userDeviceQuery) All(ctx context.Context, exec boil.ContextExecutor) (UserDeviceSlice, error) {
	var o []*UserDevice

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to UserDevice slice")
	}

	if len(userDeviceAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all UserDevice records in the query.
func (q userDeviceQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count user_devices rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q userDeviceQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if user_devices exists")
	}

	return count > 0, nil
}

// BurnRequest pointed to by the foreign key.
func (o *UserDevice) BurnRequest(mods ...qm.QueryMod) metaTransactionRequestQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.BurnRequestID),
	}

	queryMods = append(queryMods, mods...)

	return MetaTransactionRequests(queryMods...)
}

// MintRequest pointed to by the foreign key.
func (o *UserDevice) MintRequest(mods ...qm.QueryMod) metaTransactionRequestQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.MintRequestID),
	}

	queryMods = append(queryMods, mods...)

	return MetaTransactionRequests(queryMods...)
}

// VehicleTokenAftermarketDevice pointed to by the foreign key.
func (o *UserDevice) VehicleTokenAftermarketDevice(mods ...qm.QueryMod) aftermarketDeviceQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"vehicle_token_id\" = ?", o.TokenID),
	}

	queryMods = append(queryMods, mods...)

	return AftermarketDevices(queryMods...)
}

// VehicleTokenSyntheticDevice pointed to by the foreign key.
func (o *UserDevice) VehicleTokenSyntheticDevice(mods ...qm.QueryMod) syntheticDeviceQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"vehicle_token_id\" = ?", o.TokenID),
	}

	queryMods = append(queryMods, mods...)

	return SyntheticDevices(queryMods...)
}

// AutopiJobs retrieves all the autopi_job's AutopiJobs with an executor.
func (o *UserDevice) AutopiJobs(mods ...qm.QueryMod) autopiJobQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"devices_api\".\"autopi_jobs\".\"user_device_id\"=?", o.ID),
	)

	return AutopiJobs(queryMods...)
}

// DeviceCommandRequests retrieves all the device_command_request's DeviceCommandRequests with an executor.
func (o *UserDevice) DeviceCommandRequests(mods ...qm.QueryMod) deviceCommandRequestQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"devices_api\".\"device_command_requests\".\"user_device_id\"=?", o.ID),
	)

	return DeviceCommandRequests(queryMods...)
}

// ErrorCodeQueries retrieves all the error_code_query's ErrorCodeQueries with an executor.
func (o *UserDevice) ErrorCodeQueries(mods ...qm.QueryMod) errorCodeQueryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"devices_api\".\"error_code_queries\".\"user_device_id\"=?", o.ID),
	)

	return ErrorCodeQueries(queryMods...)
}

// VehicleTokenErrorCodeQueries retrieves all the error_code_query's ErrorCodeQueries with an executor via vehicle_token_id column.
func (o *UserDevice) VehicleTokenErrorCodeQueries(mods ...qm.QueryMod) errorCodeQueryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"devices_api\".\"error_code_queries\".\"vehicle_token_id\"=?", o.TokenID),
	)

	return ErrorCodeQueries(queryMods...)
}

// UserDeviceAPIIntegrations retrieves all the user_device_api_integration's UserDeviceAPIIntegrations with an executor.
func (o *UserDevice) UserDeviceAPIIntegrations(mods ...qm.QueryMod) userDeviceAPIIntegrationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"devices_api\".\"user_device_api_integrations\".\"user_device_id\"=?", o.ID),
	)

	return UserDeviceAPIIntegrations(queryMods...)
}

// UserDeviceToGeofences retrieves all the user_device_to_geofence's UserDeviceToGeofences with an executor.
func (o *UserDevice) UserDeviceToGeofences(mods ...qm.QueryMod) userDeviceToGeofenceQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"devices_api\".\"user_device_to_geofence\".\"user_device_id\"=?", o.ID),
	)

	return UserDeviceToGeofences(queryMods...)
}

// LoadBurnRequest allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userDeviceL) LoadBurnRequest(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserDevice interface{}, mods queries.Applicator) error {
	var slice []*UserDevice
	var object *UserDevice

	if singular {
		var ok bool
		object, ok = maybeUserDevice.(*UserDevice)
		if !ok {
			object = new(UserDevice)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUserDevice))
			}
		}
	} else {
		s, ok := maybeUserDevice.(*[]*UserDevice)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUserDevice))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userDeviceR{}
		}
		if !queries.IsNil(object.BurnRequestID) {
			args[object.BurnRequestID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userDeviceR{}
			}

			if !queries.IsNil(obj.BurnRequestID) {
				args[obj.BurnRequestID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`devices_api.meta_transaction_requests`),
		qm.WhereIn(`devices_api.meta_transaction_requests.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MetaTransactionRequest")
	}

	var resultSlice []*MetaTransactionRequest
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MetaTransactionRequest")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for meta_transaction_requests")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for meta_transaction_requests")
	}

	if len(metaTransactionRequestAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BurnRequest = foreign
		if foreign.R == nil {
			foreign.R = &metaTransactionRequestR{}
		}
		foreign.R.BurnRequestUserDevice = object
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BurnRequestID, foreign.ID) {
				local.R.BurnRequest = foreign
				if foreign.R == nil {
					foreign.R = &metaTransactionRequestR{}
				}
				foreign.R.BurnRequestUserDevice = local
				break
			}
		}
	}

	return nil
}

// LoadMintRequest allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userDeviceL) LoadMintRequest(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserDevice interface{}, mods queries.Applicator) error {
	var slice []*UserDevice
	var object *UserDevice

	if singular {
		var ok bool
		object, ok = maybeUserDevice.(*UserDevice)
		if !ok {
			object = new(UserDevice)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUserDevice))
			}
		}
	} else {
		s, ok := maybeUserDevice.(*[]*UserDevice)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUserDevice))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userDeviceR{}
		}
		if !queries.IsNil(object.MintRequestID) {
			args[object.MintRequestID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userDeviceR{}
			}

			if !queries.IsNil(obj.MintRequestID) {
				args[obj.MintRequestID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`devices_api.meta_transaction_requests`),
		qm.WhereIn(`devices_api.meta_transaction_requests.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MetaTransactionRequest")
	}

	var resultSlice []*MetaTransactionRequest
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MetaTransactionRequest")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for meta_transaction_requests")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for meta_transaction_requests")
	}

	if len(metaTransactionRequestAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.MintRequest = foreign
		if foreign.R == nil {
			foreign.R = &metaTransactionRequestR{}
		}
		foreign.R.MintRequestUserDevice = object
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.MintRequestID, foreign.ID) {
				local.R.MintRequest = foreign
				if foreign.R == nil {
					foreign.R = &metaTransactionRequestR{}
				}
				foreign.R.MintRequestUserDevice = local
				break
			}
		}
	}

	return nil
}

// LoadVehicleTokenAftermarketDevice allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (userDeviceL) LoadVehicleTokenAftermarketDevice(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserDevice interface{}, mods queries.Applicator) error {
	var slice []*UserDevice
	var object *UserDevice

	if singular {
		var ok bool
		object, ok = maybeUserDevice.(*UserDevice)
		if !ok {
			object = new(UserDevice)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUserDevice))
			}
		}
	} else {
		s, ok := maybeUserDevice.(*[]*UserDevice)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUserDevice))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userDeviceR{}
		}
		args[object.TokenID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userDeviceR{}
			}

			args[obj.TokenID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`devices_api.aftermarket_devices`),
		qm.WhereIn(`devices_api.aftermarket_devices.vehicle_token_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load AftermarketDevice")
	}

	var resultSlice []*AftermarketDevice
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice AftermarketDevice")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for aftermarket_devices")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for aftermarket_devices")
	}

	if len(aftermarketDeviceAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.VehicleTokenAftermarketDevice = foreign
		if foreign.R == nil {
			foreign.R = &aftermarketDeviceR{}
		}
		foreign.R.VehicleToken = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.TokenID, foreign.VehicleTokenID) {
				local.R.VehicleTokenAftermarketDevice = foreign
				if foreign.R == nil {
					foreign.R = &aftermarketDeviceR{}
				}
				foreign.R.VehicleToken = local
				break
			}
		}
	}

	return nil
}

// LoadVehicleTokenSyntheticDevice allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (userDeviceL) LoadVehicleTokenSyntheticDevice(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserDevice interface{}, mods queries.Applicator) error {
	var slice []*UserDevice
	var object *UserDevice

	if singular {
		var ok bool
		object, ok = maybeUserDevice.(*UserDevice)
		if !ok {
			object = new(UserDevice)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUserDevice))
			}
		}
	} else {
		s, ok := maybeUserDevice.(*[]*UserDevice)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUserDevice))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userDeviceR{}
		}
		args[object.TokenID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userDeviceR{}
			}

			args[obj.TokenID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`devices_api.synthetic_devices`),
		qm.WhereIn(`devices_api.synthetic_devices.vehicle_token_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SyntheticDevice")
	}

	var resultSlice []*SyntheticDevice
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SyntheticDevice")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for synthetic_devices")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for synthetic_devices")
	}

	if len(syntheticDeviceAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.VehicleTokenSyntheticDevice = foreign
		if foreign.R == nil {
			foreign.R = &syntheticDeviceR{}
		}
		foreign.R.VehicleToken = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.TokenID, foreign.VehicleTokenID) {
				local.R.VehicleTokenSyntheticDevice = foreign
				if foreign.R == nil {
					foreign.R = &syntheticDeviceR{}
				}
				foreign.R.VehicleToken = local
				break
			}
		}
	}

	return nil
}

// LoadAutopiJobs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userDeviceL) LoadAutopiJobs(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserDevice interface{}, mods queries.Applicator) error {
	var slice []*UserDevice
	var object *UserDevice

	if singular {
		var ok bool
		object, ok = maybeUserDevice.(*UserDevice)
		if !ok {
			object = new(UserDevice)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUserDevice))
			}
		}
	} else {
		s, ok := maybeUserDevice.(*[]*UserDevice)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUserDevice))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userDeviceR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userDeviceR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`devices_api.autopi_jobs`),
		qm.WhereIn(`devices_api.autopi_jobs.user_device_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load autopi_jobs")
	}

	var resultSlice []*AutopiJob
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice autopi_jobs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on autopi_jobs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for autopi_jobs")
	}

	if len(autopiJobAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AutopiJobs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &autopiJobR{}
			}
			foreign.R.UserDevice = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.UserDeviceID) {
				local.R.AutopiJobs = append(local.R.AutopiJobs, foreign)
				if foreign.R == nil {
					foreign.R = &autopiJobR{}
				}
				foreign.R.UserDevice = local
				break
			}
		}
	}

	return nil
}

// LoadDeviceCommandRequests allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userDeviceL) LoadDeviceCommandRequests(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserDevice interface{}, mods queries.Applicator) error {
	var slice []*UserDevice
	var object *UserDevice

	if singular {
		var ok bool
		object, ok = maybeUserDevice.(*UserDevice)
		if !ok {
			object = new(UserDevice)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUserDevice))
			}
		}
	} else {
		s, ok := maybeUserDevice.(*[]*UserDevice)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUserDevice))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userDeviceR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userDeviceR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`devices_api.device_command_requests`),
		qm.WhereIn(`devices_api.device_command_requests.user_device_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load device_command_requests")
	}

	var resultSlice []*DeviceCommandRequest
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice device_command_requests")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on device_command_requests")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for device_command_requests")
	}

	if len(deviceCommandRequestAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DeviceCommandRequests = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &deviceCommandRequestR{}
			}
			foreign.R.UserDevice = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserDeviceID {
				local.R.DeviceCommandRequests = append(local.R.DeviceCommandRequests, foreign)
				if foreign.R == nil {
					foreign.R = &deviceCommandRequestR{}
				}
				foreign.R.UserDevice = local
				break
			}
		}
	}

	return nil
}

// LoadErrorCodeQueries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userDeviceL) LoadErrorCodeQueries(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserDevice interface{}, mods queries.Applicator) error {
	var slice []*UserDevice
	var object *UserDevice

	if singular {
		var ok bool
		object, ok = maybeUserDevice.(*UserDevice)
		if !ok {
			object = new(UserDevice)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUserDevice))
			}
		}
	} else {
		s, ok := maybeUserDevice.(*[]*UserDevice)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUserDevice))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userDeviceR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userDeviceR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`devices_api.error_code_queries`),
		qm.WhereIn(`devices_api.error_code_queries.user_device_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load error_code_queries")
	}

	var resultSlice []*ErrorCodeQuery
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice error_code_queries")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on error_code_queries")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for error_code_queries")
	}

	if len(errorCodeQueryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ErrorCodeQueries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &errorCodeQueryR{}
			}
			foreign.R.UserDevice = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserDeviceID {
				local.R.ErrorCodeQueries = append(local.R.ErrorCodeQueries, foreign)
				if foreign.R == nil {
					foreign.R = &errorCodeQueryR{}
				}
				foreign.R.UserDevice = local
				break
			}
		}
	}

	return nil
}

// LoadVehicleTokenErrorCodeQueries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userDeviceL) LoadVehicleTokenErrorCodeQueries(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserDevice interface{}, mods queries.Applicator) error {
	var slice []*UserDevice
	var object *UserDevice

	if singular {
		var ok bool
		object, ok = maybeUserDevice.(*UserDevice)
		if !ok {
			object = new(UserDevice)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUserDevice))
			}
		}
	} else {
		s, ok := maybeUserDevice.(*[]*UserDevice)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUserDevice))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userDeviceR{}
		}
		args[object.TokenID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userDeviceR{}
			}
			args[obj.TokenID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`devices_api.error_code_queries`),
		qm.WhereIn(`devices_api.error_code_queries.vehicle_token_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load error_code_queries")
	}

	var resultSlice []*ErrorCodeQuery
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice error_code_queries")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on error_code_queries")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for error_code_queries")
	}

	if len(errorCodeQueryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.VehicleTokenErrorCodeQueries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &errorCodeQueryR{}
			}
			foreign.R.VehicleToken = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.TokenID, foreign.VehicleTokenID) {
				local.R.VehicleTokenErrorCodeQueries = append(local.R.VehicleTokenErrorCodeQueries, foreign)
				if foreign.R == nil {
					foreign.R = &errorCodeQueryR{}
				}
				foreign.R.VehicleToken = local
				break
			}
		}
	}

	return nil
}

// LoadUserDeviceAPIIntegrations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userDeviceL) LoadUserDeviceAPIIntegrations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserDevice interface{}, mods queries.Applicator) error {
	var slice []*UserDevice
	var object *UserDevice

	if singular {
		var ok bool
		object, ok = maybeUserDevice.(*UserDevice)
		if !ok {
			object = new(UserDevice)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUserDevice))
			}
		}
	} else {
		s, ok := maybeUserDevice.(*[]*UserDevice)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUserDevice))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userDeviceR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userDeviceR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`devices_api.user_device_api_integrations`),
		qm.WhereIn(`devices_api.user_device_api_integrations.user_device_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_device_api_integrations")
	}

	var resultSlice []*UserDeviceAPIIntegration
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_device_api_integrations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_device_api_integrations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_device_api_integrations")
	}

	if len(userDeviceAPIIntegrationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserDeviceAPIIntegrations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userDeviceAPIIntegrationR{}
			}
			foreign.R.UserDevice = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserDeviceID {
				local.R.UserDeviceAPIIntegrations = append(local.R.UserDeviceAPIIntegrations, foreign)
				if foreign.R == nil {
					foreign.R = &userDeviceAPIIntegrationR{}
				}
				foreign.R.UserDevice = local
				break
			}
		}
	}

	return nil
}

// LoadUserDeviceToGeofences allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userDeviceL) LoadUserDeviceToGeofences(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserDevice interface{}, mods queries.Applicator) error {
	var slice []*UserDevice
	var object *UserDevice

	if singular {
		var ok bool
		object, ok = maybeUserDevice.(*UserDevice)
		if !ok {
			object = new(UserDevice)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUserDevice))
			}
		}
	} else {
		s, ok := maybeUserDevice.(*[]*UserDevice)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUserDevice)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUserDevice))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userDeviceR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userDeviceR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`devices_api.user_device_to_geofence`),
		qm.WhereIn(`devices_api.user_device_to_geofence.user_device_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_device_to_geofence")
	}

	var resultSlice []*UserDeviceToGeofence
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_device_to_geofence")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_device_to_geofence")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_device_to_geofence")
	}

	if len(userDeviceToGeofenceAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserDeviceToGeofences = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userDeviceToGeofenceR{}
			}
			foreign.R.UserDevice = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserDeviceID {
				local.R.UserDeviceToGeofences = append(local.R.UserDeviceToGeofences, foreign)
				if foreign.R == nil {
					foreign.R = &userDeviceToGeofenceR{}
				}
				foreign.R.UserDevice = local
				break
			}
		}
	}

	return nil
}

// SetBurnRequest of the userDevice to the related item.
// Sets o.R.BurnRequest to related.
// Adds o to related.R.BurnRequestUserDevice.
func (o *UserDevice) SetBurnRequest(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MetaTransactionRequest) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"devices_api\".\"user_devices\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"burn_request_id"}),
		strmangle.WhereClause("\"", "\"", 2, userDevicePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BurnRequestID, related.ID)
	if o.R == nil {
		o.R = &userDeviceR{
			BurnRequest: related,
		}
	} else {
		o.R.BurnRequest = related
	}

	if related.R == nil {
		related.R = &metaTransactionRequestR{
			BurnRequestUserDevice: o,
		}
	} else {
		related.R.BurnRequestUserDevice = o
	}

	return nil
}

// RemoveBurnRequest relationship.
// Sets o.R.BurnRequest to nil.
// Removes o from all passed in related items' relationships struct.
func (o *UserDevice) RemoveBurnRequest(ctx context.Context, exec boil.ContextExecutor, related *MetaTransactionRequest) error {
	var err error

	queries.SetScanner(&o.BurnRequestID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("burn_request_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BurnRequest = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	related.R.BurnRequestUserDevice = nil
	return nil
}

// SetMintRequest of the userDevice to the related item.
// Sets o.R.MintRequest to related.
// Adds o to related.R.MintRequestUserDevice.
func (o *UserDevice) SetMintRequest(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MetaTransactionRequest) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"devices_api\".\"user_devices\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"mint_request_id"}),
		strmangle.WhereClause("\"", "\"", 2, userDevicePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.MintRequestID, related.ID)
	if o.R == nil {
		o.R = &userDeviceR{
			MintRequest: related,
		}
	} else {
		o.R.MintRequest = related
	}

	if related.R == nil {
		related.R = &metaTransactionRequestR{
			MintRequestUserDevice: o,
		}
	} else {
		related.R.MintRequestUserDevice = o
	}

	return nil
}

// RemoveMintRequest relationship.
// Sets o.R.MintRequest to nil.
// Removes o from all passed in related items' relationships struct.
func (o *UserDevice) RemoveMintRequest(ctx context.Context, exec boil.ContextExecutor, related *MetaTransactionRequest) error {
	var err error

	queries.SetScanner(&o.MintRequestID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("mint_request_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.MintRequest = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	related.R.MintRequestUserDevice = nil
	return nil
}

// SetVehicleTokenAftermarketDevice of the userDevice to the related item.
// Sets o.R.VehicleTokenAftermarketDevice to related.
// Adds o to related.R.VehicleToken.
func (o *UserDevice) SetVehicleTokenAftermarketDevice(ctx context.Context, exec boil.ContextExecutor, insert bool, related *AftermarketDevice) error {
	var err error

	if insert {
		queries.Assign(&related.VehicleTokenID, o.TokenID)

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"devices_api\".\"aftermarket_devices\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"vehicle_token_id"}),
			strmangle.WhereClause("\"", "\"", 2, aftermarketDevicePrimaryKeyColumns),
		)
		values := []interface{}{o.TokenID, related.EthereumAddress}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.VehicleTokenID, o.TokenID)
	}

	if o.R == nil {
		o.R = &userDeviceR{
			VehicleTokenAftermarketDevice: related,
		}
	} else {
		o.R.VehicleTokenAftermarketDevice = related
	}

	if related.R == nil {
		related.R = &aftermarketDeviceR{
			VehicleToken: o,
		}
	} else {
		related.R.VehicleToken = o
	}
	return nil
}

// RemoveVehicleTokenAftermarketDevice relationship.
// Sets o.R.VehicleTokenAftermarketDevice to nil.
// Removes o from all passed in related items' relationships struct.
func (o *UserDevice) RemoveVehicleTokenAftermarketDevice(ctx context.Context, exec boil.ContextExecutor, related *AftermarketDevice) error {
	var err error

	queries.SetScanner(&related.VehicleTokenID, nil)
	if _, err = related.Update(ctx, exec, boil.Whitelist("vehicle_token_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.VehicleTokenAftermarketDevice = nil
	}

	if related == nil || related.R == nil {
		return nil
	}

	related.R.VehicleToken = nil

	return nil
}

// SetVehicleTokenSyntheticDevice of the userDevice to the related item.
// Sets o.R.VehicleTokenSyntheticDevice to related.
// Adds o to related.R.VehicleToken.
func (o *UserDevice) SetVehicleTokenSyntheticDevice(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SyntheticDevice) error {
	var err error

	if insert {
		queries.Assign(&related.VehicleTokenID, o.TokenID)

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"devices_api\".\"synthetic_devices\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"vehicle_token_id"}),
			strmangle.WhereClause("\"", "\"", 2, syntheticDevicePrimaryKeyColumns),
		)
		values := []interface{}{o.TokenID, related.MintRequestID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.VehicleTokenID, o.TokenID)
	}

	if o.R == nil {
		o.R = &userDeviceR{
			VehicleTokenSyntheticDevice: related,
		}
	} else {
		o.R.VehicleTokenSyntheticDevice = related
	}

	if related.R == nil {
		related.R = &syntheticDeviceR{
			VehicleToken: o,
		}
	} else {
		related.R.VehicleToken = o
	}
	return nil
}

// RemoveVehicleTokenSyntheticDevice relationship.
// Sets o.R.VehicleTokenSyntheticDevice to nil.
// Removes o from all passed in related items' relationships struct.
func (o *UserDevice) RemoveVehicleTokenSyntheticDevice(ctx context.Context, exec boil.ContextExecutor, related *SyntheticDevice) error {
	var err error

	queries.SetScanner(&related.VehicleTokenID, nil)
	if _, err = related.Update(ctx, exec, boil.Whitelist("vehicle_token_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.VehicleTokenSyntheticDevice = nil
	}

	if related == nil || related.R == nil {
		return nil
	}

	related.R.VehicleToken = nil

	return nil
}

// AddAutopiJobs adds the given related objects to the existing relationships
// of the user_device, optionally inserting them as new records.
// Appends related to o.R.AutopiJobs.
// Sets related.R.UserDevice appropriately.
func (o *UserDevice) AddAutopiJobs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AutopiJob) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.UserDeviceID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"devices_api\".\"autopi_jobs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_device_id"}),
				strmangle.WhereClause("\"", "\"", 2, autopiJobPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.UserDeviceID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userDeviceR{
			AutopiJobs: related,
		}
	} else {
		o.R.AutopiJobs = append(o.R.AutopiJobs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &autopiJobR{
				UserDevice: o,
			}
		} else {
			rel.R.UserDevice = o
		}
	}
	return nil
}

// SetAutopiJobs removes all previously related items of the
// user_device replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.UserDevice's AutopiJobs accordingly.
// Replaces o.R.AutopiJobs with related.
// Sets related.R.UserDevice's AutopiJobs accordingly.
func (o *UserDevice) SetAutopiJobs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AutopiJob) error {
	query := "update \"devices_api\".\"autopi_jobs\" set \"user_device_id\" = null where \"user_device_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.AutopiJobs {
			queries.SetScanner(&rel.UserDeviceID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.UserDevice = nil
		}
		o.R.AutopiJobs = nil
	}

	return o.AddAutopiJobs(ctx, exec, insert, related...)
}

// RemoveAutopiJobs relationships from objects passed in.
// Removes related items from R.AutopiJobs (uses pointer comparison, removal does not keep order)
// Sets related.R.UserDevice.
func (o *UserDevice) RemoveAutopiJobs(ctx context.Context, exec boil.ContextExecutor, related ...*AutopiJob) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.UserDeviceID, nil)
		if rel.R != nil {
			rel.R.UserDevice = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("user_device_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.AutopiJobs {
			if rel != ri {
				continue
			}

			ln := len(o.R.AutopiJobs)
			if ln > 1 && i < ln-1 {
				o.R.AutopiJobs[i] = o.R.AutopiJobs[ln-1]
			}
			o.R.AutopiJobs = o.R.AutopiJobs[:ln-1]
			break
		}
	}

	return nil
}

// AddDeviceCommandRequests adds the given related objects to the existing relationships
// of the user_device, optionally inserting them as new records.
// Appends related to o.R.DeviceCommandRequests.
// Sets related.R.UserDevice appropriately.
func (o *UserDevice) AddDeviceCommandRequests(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DeviceCommandRequest) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserDeviceID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"devices_api\".\"device_command_requests\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_device_id"}),
				strmangle.WhereClause("\"", "\"", 2, deviceCommandRequestPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserDeviceID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userDeviceR{
			DeviceCommandRequests: related,
		}
	} else {
		o.R.DeviceCommandRequests = append(o.R.DeviceCommandRequests, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &deviceCommandRequestR{
				UserDevice: o,
			}
		} else {
			rel.R.UserDevice = o
		}
	}
	return nil
}

// AddErrorCodeQueries adds the given related objects to the existing relationships
// of the user_device, optionally inserting them as new records.
// Appends related to o.R.ErrorCodeQueries.
// Sets related.R.UserDevice appropriately.
func (o *UserDevice) AddErrorCodeQueries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ErrorCodeQuery) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserDeviceID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"devices_api\".\"error_code_queries\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_device_id"}),
				strmangle.WhereClause("\"", "\"", 2, errorCodeQueryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserDeviceID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userDeviceR{
			ErrorCodeQueries: related,
		}
	} else {
		o.R.ErrorCodeQueries = append(o.R.ErrorCodeQueries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &errorCodeQueryR{
				UserDevice: o,
			}
		} else {
			rel.R.UserDevice = o
		}
	}
	return nil
}

// AddVehicleTokenErrorCodeQueries adds the given related objects to the existing relationships
// of the user_device, optionally inserting them as new records.
// Appends related to o.R.VehicleTokenErrorCodeQueries.
// Sets related.R.VehicleToken appropriately.
func (o *UserDevice) AddVehicleTokenErrorCodeQueries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ErrorCodeQuery) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.VehicleTokenID, o.TokenID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"devices_api\".\"error_code_queries\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"vehicle_token_id"}),
				strmangle.WhereClause("\"", "\"", 2, errorCodeQueryPrimaryKeyColumns),
			)
			values := []interface{}{o.TokenID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.VehicleTokenID, o.TokenID)
		}
	}

	if o.R == nil {
		o.R = &userDeviceR{
			VehicleTokenErrorCodeQueries: related,
		}
	} else {
		o.R.VehicleTokenErrorCodeQueries = append(o.R.VehicleTokenErrorCodeQueries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &errorCodeQueryR{
				VehicleToken: o,
			}
		} else {
			rel.R.VehicleToken = o
		}
	}
	return nil
}

// SetVehicleTokenErrorCodeQueries removes all previously related items of the
// user_device replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.VehicleToken's VehicleTokenErrorCodeQueries accordingly.
// Replaces o.R.VehicleTokenErrorCodeQueries with related.
// Sets related.R.VehicleToken's VehicleTokenErrorCodeQueries accordingly.
func (o *UserDevice) SetVehicleTokenErrorCodeQueries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ErrorCodeQuery) error {
	query := "update \"devices_api\".\"error_code_queries\" set \"vehicle_token_id\" = null where \"vehicle_token_id\" = $1"
	values := []interface{}{o.TokenID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.VehicleTokenErrorCodeQueries {
			queries.SetScanner(&rel.VehicleTokenID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.VehicleToken = nil
		}
		o.R.VehicleTokenErrorCodeQueries = nil
	}

	return o.AddVehicleTokenErrorCodeQueries(ctx, exec, insert, related...)
}

// RemoveVehicleTokenErrorCodeQueries relationships from objects passed in.
// Removes related items from R.VehicleTokenErrorCodeQueries (uses pointer comparison, removal does not keep order)
// Sets related.R.VehicleToken.
func (o *UserDevice) RemoveVehicleTokenErrorCodeQueries(ctx context.Context, exec boil.ContextExecutor, related ...*ErrorCodeQuery) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.VehicleTokenID, nil)
		if rel.R != nil {
			rel.R.VehicleToken = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("vehicle_token_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.VehicleTokenErrorCodeQueries {
			if rel != ri {
				continue
			}

			ln := len(o.R.VehicleTokenErrorCodeQueries)
			if ln > 1 && i < ln-1 {
				o.R.VehicleTokenErrorCodeQueries[i] = o.R.VehicleTokenErrorCodeQueries[ln-1]
			}
			o.R.VehicleTokenErrorCodeQueries = o.R.VehicleTokenErrorCodeQueries[:ln-1]
			break
		}
	}

	return nil
}

// AddUserDeviceAPIIntegrations adds the given related objects to the existing relationships
// of the user_device, optionally inserting them as new records.
// Appends related to o.R.UserDeviceAPIIntegrations.
// Sets related.R.UserDevice appropriately.
func (o *UserDevice) AddUserDeviceAPIIntegrations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserDeviceAPIIntegration) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserDeviceID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"devices_api\".\"user_device_api_integrations\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_device_id"}),
				strmangle.WhereClause("\"", "\"", 2, userDeviceAPIIntegrationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.UserDeviceID, rel.IntegrationID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserDeviceID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userDeviceR{
			UserDeviceAPIIntegrations: related,
		}
	} else {
		o.R.UserDeviceAPIIntegrations = append(o.R.UserDeviceAPIIntegrations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userDeviceAPIIntegrationR{
				UserDevice: o,
			}
		} else {
			rel.R.UserDevice = o
		}
	}
	return nil
}

// AddUserDeviceToGeofences adds the given related objects to the existing relationships
// of the user_device, optionally inserting them as new records.
// Appends related to o.R.UserDeviceToGeofences.
// Sets related.R.UserDevice appropriately.
func (o *UserDevice) AddUserDeviceToGeofences(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserDeviceToGeofence) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserDeviceID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"devices_api\".\"user_device_to_geofence\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_device_id"}),
				strmangle.WhereClause("\"", "\"", 2, userDeviceToGeofencePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.UserDeviceID, rel.GeofenceID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserDeviceID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userDeviceR{
			UserDeviceToGeofences: related,
		}
	} else {
		o.R.UserDeviceToGeofences = append(o.R.UserDeviceToGeofences, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userDeviceToGeofenceR{
				UserDevice: o,
			}
		} else {
			rel.R.UserDevice = o
		}
	}
	return nil
}

// UserDevices retrieves all the records using an executor.
func UserDevices(mods ...qm.QueryMod) userDeviceQuery {
	mods = append(mods, qm.From("\"devices_api\".\"user_devices\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"devices_api\".\"user_devices\".*"})
	}

	return userDeviceQuery{q}
}

// FindUserDevice retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindUserDevice(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*UserDevice, error) {
	userDeviceObj := &UserDevice{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"devices_api\".\"user_devices\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, userDeviceObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from user_devices")
	}

	if err = userDeviceObj.doAfterSelectHooks(ctx, exec); err != nil {
		return userDeviceObj, err
	}

	return userDeviceObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *UserDevice) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no user_devices provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userDeviceColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	userDeviceInsertCacheMut.RLock()
	cache, cached := userDeviceInsertCache[key]
	userDeviceInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			userDeviceAllColumns,
			userDeviceColumnsWithDefault,
			userDeviceColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(userDeviceType, userDeviceMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(userDeviceType, userDeviceMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"devices_api\".\"user_devices\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"devices_api\".\"user_devices\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into user_devices")
	}

	if !cached {
		userDeviceInsertCacheMut.Lock()
		userDeviceInsertCache[key] = cache
		userDeviceInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the UserDevice.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *UserDevice) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	userDeviceUpdateCacheMut.RLock()
	cache, cached := userDeviceUpdateCache[key]
	userDeviceUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			userDeviceAllColumns,
			userDevicePrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update user_devices, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"devices_api\".\"user_devices\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, userDevicePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(userDeviceType, userDeviceMapping, append(wl, userDevicePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update user_devices row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for user_devices")
	}

	if !cached {
		userDeviceUpdateCacheMut.Lock()
		userDeviceUpdateCache[key] = cache
		userDeviceUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q userDeviceQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for user_devices")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for user_devices")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o UserDeviceSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userDevicePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"devices_api\".\"user_devices\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, userDevicePrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in userDevice slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all userDevice")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *UserDevice) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("models: no user_devices provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userDeviceColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	userDeviceUpsertCacheMut.RLock()
	cache, cached := userDeviceUpsertCache[key]
	userDeviceUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			userDeviceAllColumns,
			userDeviceColumnsWithDefault,
			userDeviceColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			userDeviceAllColumns,
			userDevicePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert user_devices, could not build update column list")
		}

		ret := strmangle.SetComplement(userDeviceAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(userDevicePrimaryKeyColumns) == 0 {
				return errors.New("models: unable to upsert user_devices, could not build conflict column list")
			}

			conflict = make([]string, len(userDevicePrimaryKeyColumns))
			copy(conflict, userDevicePrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"devices_api\".\"user_devices\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(userDeviceType, userDeviceMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(userDeviceType, userDeviceMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert user_devices")
	}

	if !cached {
		userDeviceUpsertCacheMut.Lock()
		userDeviceUpsertCache[key] = cache
		userDeviceUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single UserDevice record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *UserDevice) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no UserDevice provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), userDevicePrimaryKeyMapping)
	sql := "DELETE FROM \"devices_api\".\"user_devices\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from user_devices")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for user_devices")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q userDeviceQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no userDeviceQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from user_devices")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for user_devices")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o UserDeviceSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(userDeviceBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userDevicePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"devices_api\".\"user_devices\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userDevicePrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from userDevice slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for user_devices")
	}

	if len(userDeviceAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *UserDevice) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindUserDevice(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *UserDeviceSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := UserDeviceSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userDevicePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"devices_api\".\"user_devices\".* FROM \"devices_api\".\"user_devices\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userDevicePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in UserDeviceSlice")
	}

	*o = slice

	return nil
}

// UserDeviceExists checks if the UserDevice row exists.
func UserDeviceExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"devices_api\".\"user_devices\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if user_devices exists")
	}

	return exists, nil
}

// Exists checks if the UserDevice row exists.
func (o *UserDevice) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return UserDeviceExists(ctx, exec, o.ID)
}
